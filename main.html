<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>턴제 카드 게임</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #333;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            overflow-y: auto;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #444;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 95%;
            box-sizing: border-box;
            position: relative;
            margin: 20px 0;
        }

        #gameCanvas {
            border: 2px solid #666;
            background-color: #1a1a1a;
            border-radius: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }

        .ui-panel {
            display: flex;
            width: 100%;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .ui-panel div {
            padding: 10px 15px;
            background: #555;
            border-radius: 10px;
            margin: 5px;
            white-space: nowrap;
        }

        .ui-panel h3 {
            margin: 0;
            font-size: 1.2em;
        }
        
        .ui-panel p {
            margin: 0;
            font-size: 1em;
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            text-align: left;
            align-items: flex-start;
        }

        .turn-and-next-cards {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .next-cards-info {
            background-color: #555;
            border-radius: 10px;
            padding: 10px 15px;
            text-align: center;
        }
        
        .next-cards-info h4 {
            margin: 0 0 5px 0;
            font-size: 0.9em;
        }
        
        .next-card-list {
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .next-card {
            background-color: #777;
            padding: 5px;
            border-radius: 5px;
            font-size: 0.8em;
        }

        #messageBox {
            width: 100%;
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 25px;
            box-sizing: border-box;
        }

        #endTurnBtn {
            padding: 12px 25px;
            font-size: 1.1em;
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-top: 10px;
        }

        #endTurnBtn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }

        #endTurnBtn:disabled {
            background-color: #777;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .hand {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .card {
            background-color: #666;
            border-radius: 8px;
            padding: 8px;
            width: 100px;
            min-height: 120px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            word-break: keep-all;
        }
        
        .card:hover {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.7);
        }

        .card.selected {
            border: 3px solid #FFD700;
            transform: scale(1.1);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }
        
        .card.disabled-action {
            background-color: #999;
            cursor: not-allowed;
        }

        .card-name {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .card-stats {
            font-size: 0.9em;
            line-height: 1.4;
        }

        .card-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #555;
            padding: 3px 5px;
            border-radius: 5px;
            margin-top: 5px;
        }

        .card-stat span {
            font-size: 0.8em;
        }

        .cost-circle {
            background-color: #33aaff;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1em;
            font-weight: bold;
            position: absolute;
            top: -5px;
            right: -5px;
            border: 2px solid white;
        }

        /* ===== Info Button Bar & Modal Styles ===== */
        .top-actions {
            display: flex;
            gap: 10px;
            width: 100%;
            justify-content: flex-end;
            margin: 8px 0 0 0;
            flex-wrap: wrap;
        }
        .info-btn {
            padding: 10px 14px;
            background: #3b82f6;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform .15s ease, opacity .15s ease;
        }
        .info-btn:hover { transform: translateY(-1px); }
        .info-btn:active { transform: translateY(0); opacity: .9; }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            display: none; /* hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 16px;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            width: min(900px, 95vw);
            max-height: 85vh;
            background: #2b2b2b;
            color: #eee;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid #555;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #3a3a3a;
            border-bottom: 1px solid #555;
        }
        .modal-title { font-size: 1.05rem; font-weight: 700; margin: 0; }
        .modal-close {
            background: transparent;
            border: none;
            color: #ddd;
            font-size: 1.3rem;
            cursor: pointer;
            line-height: 1;
        }
        .modal-body {
            padding: 14px 16px;
            overflow: auto;
        }
        .helper-note {
            font-size: .9rem;
            color: #cbd5e1;
            background: #1f2937;
            padding: 10px;
            border-radius: 8px;
            border: 1px dashed #475569;
        }
        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }
        .codex-card {
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 10px;
            padding: 10px;
        }
        .codex-card h4 { margin: 0 0 6px 0; font-size: 1rem; }
        .codex-card p { margin: 0; font-size: .9rem; color: #d1d5db; }
        .rule-list ol { margin: 0; padding-left: 20px; }
        .rule-list li { margin-bottom: 6px; line-height: 1.4; }
        .rule-note { margin: 6px 0 0 0; font-size: .9rem; color: #cbd5e1; }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="messageBox">게임이 시작됩니다!</div>
        <div class="top-actions">
            <button id="btnRules" class="info-btn" aria-haspopup="dialog" aria-controls="rulesModal">규칙 보기</button>
            <button id="btnCodex" class="info-btn" aria-haspopup="dialog" aria-controls="codexModal">캐릭터 도감</button>
        </div>
        <div class="ui-panel">
            <div class="player-info" id="player2-info">
                <h3>플레이어 2</h3>
                <p>생명: <span id="player2Health"></span></p>
                <p>코스트: <span id="player2Cost"></span></p>
            </div>
            <div class="turn-and-next-cards">
                <div>
                    <h3>현재 턴: <span id="currentPlayerLabel">플레이어 1</span></h3>
                    <h3>턴: <span id="turnCounter">1</span></h3>
                    <h3>행동 횟수: <span id="actionPoints"></span></h3>
                </div>
                <div class="next-cards-info">
                    <h4>다음 카드</h4>
                    <div class="next-card-list" id="nextCards"></div>
                </div>
            </div>
            <div class="player-info" id="player1-info">
                <h3>플레이어 1</h3>
                <p>생명: <span id="player1Health"></span></p>
                <p>코스트: <span id="player1Cost"></span></p>
            </div>
        </div>
        <canvas id="gameCanvas" width="480" height="720"></canvas>
        <div class="hand" id="playerHand"></div>
        <button id="endTurnBtn">턴 종료</button>

        <!-- 규칙 모달 -->
        <div id="rulesModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="rulesTitle">
          <div class="modal" role="document">
            <div class="modal-header">
              <h3 id="rulesTitle" class="modal-title">게임 규칙</h3>
              <button class="modal-close" data-close-modal="rulesModal" aria-label="닫기">✕</button>
            </div>
            <div class="modal-body">
              <div class="helper-note">
                게임을 시작하기 전에 아래 핵심 규칙을 꼭 확인하세요.
              </div>
              <div id="rulesContent" class="rule-list" style="margin-top:10px;">
                <ol>
                  <li>상대 진영(색이 있는 마지막 칸)으로 내 카드를 보내, 상대의 생명이 다 닳면 승리.</li>
                  <li>플레이어 1, 2가 번가라 게임을 진행.</li>
                  <li>한 턴이 끝나면 코스트 3을 받음. (최대10 제한)</li>
                  <li>한 턴에 하나의 행동은 꼭 해야함.</li>
                  <li>필드에 카드를 내는 것은 제한이 없음.</li>
                  <li>6코스트 이상 카드는 필드에 나온 순간부터, 행동불가 상태에 걸림.</li>
                </ol>
                <p class="rule-note">행동불가 상태: 5턴 동안 행동할 수 없습니다.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- 캐릭터 도감 모달 -->
        <div id="codexModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="codexTitle">
          <div class="modal" role="document">
            <div class="modal-header">
              <h3 id="codexTitle" class="modal-title">캐릭터 도감</h3>
              <button class="modal-close" data-close-modal="codexModal" aria-label="닫기">✕</button>
            </div>
            <div class="modal-body">
              <div class="helper-note">
                특수 능력을 중심으로 각 카드를 빠르게 파악할 수 있도록 정리했습니다.
              </div>
              <div id="codexContent" class="codex-grid">
                <div class="codex-card">
                  <h4>병사</h4>
                  <p><strong>특수 능력</strong>: 없음.</p>
                  <p>코스트 1 · 공격 1 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>아처</h4>
                  <p><strong>특수 능력</strong>: 우리 진영에서는 사거리 2를 유지하고, 상대 진영으로 넘어가면 공격력이 1 감소합니다.</p>
                  <p>코스트 2 · 공격 2 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>방패병</h4>
                  <p><strong>특수 능력</strong>: 상대 진영으로 넘어가는 즉시 체력 +2, 공격력 -1을 받습니다.</p>
                  <p>코스트 2 · 공격 2 · 체력 3 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>힐러</h4>
                  <p><strong>특수 능력</strong>: 행동 대신 아군 카드에 힐을 사용해 공격 1을 막는 방어막을 부여합니다. 방어막은 중첩되지 않습니다.</p>
                  <p>코스트 2 · 공격 0 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>마법사</h4>
                  <p><strong>특수 능력</strong>: 사거리 2. 공격 대상과 그 뒤칸의 적에게 각각 1의 추가 피해를 줍니다.</p>
                  <p>코스트 3 · 공격 3 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>총잡이</h4>
                  <p><strong>특수 능력</strong>: 사거리 2 고정. 상대 진영으로 넘어가면 한 번의 행동으로 두 번 공격합니다.</p>
                  <p>코스트 3 · 공격 2 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>말탄창병</h4>
                  <p><strong>특수 능력</strong>: 앞·뒤·좌·우 방향으로 최대 두 칸까지 이동할 수 있습니다.</p>
                  <p>코스트 5 · 공격 5 · 체력 3 · 전진 2</p>
                </div>
                <div class="codex-card">
                  <h4>폭탄병</h4>
                  <p><strong>특수 능력</strong>: 공격 시 대상 칸 기준 앞·뒤·좌·우 한 칸에도 추가 피해 2를 줍니다.</p>
                  <p>코스트 5 · 공격 5 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>투사</h4>
                  <p><strong>특수 능력</strong>: 상대 진영 중앙을 넘어가면 체력 +3, 턴 종료마다 체력 +1을 얻습니다.</p>
                  <p>코스트 4 · 공격 4 · 체력 3 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>사형수</h4>
                  <p><strong>특수 능력</strong>: 5턴 동안 행동 불가 상태에 묶이지 않으며, 이동할 때마다 최대 체력이 1씩 증가합니다(최대 15).</p>
                  <p>코스트 8 · 공격 1 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>박쥐</h4>
                  <p><strong>특수 능력</strong>: 없음.</p>
                  <p>코스트 1 · 공격 1 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>해골</h4>
                  <p><strong>특수 능력</strong>: 없음.</p>
                  <p>코스트 1 · 공격 1 · 체력 1 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>자살맨</h4>
                  <p><strong>특수 능력</strong>: 상대 진영에만 소환 가능하며, 소환 즉시 주변 3×3 칸 적에게 피해 2를 주고 사망합니다.</p>
                  <p>코스트 5 · 공격 0 · 체력 1 · 전진 0</p>
                </div>
                <div class="codex-card">
                  <h4>넝쿨 마법</h4>
                  <p><strong>특수 능력</strong>: 어느 진영이든 소환 가능. 해당 열의 모든 카드 행동을 제한합니다.</p>
                  <p>코스트 4 · 공격 0 · 체력 0 · 전진 0</p>
                </div>
                <div class="codex-card">
                  <h4>악마</h4>
                  <p><strong>특수 능력</strong>: 아군 병사를 잡아먹고 그 자리에 소환되며, 소환 즉시 공격할 수 있습니다.</p>
                  <p>코스트 5 · 공격 5 · 체력 3 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>광부</h4>
                  <p><strong>특수 능력</strong>: 아군 진영에 있을 때 턴 시작마다 코스트를 1 더 얻습니다.</p>
                  <p>코스트 2 · 공격 1 · 체력 2 · 전진 1</p>
                </div>
                <div class="codex-card">
                  <h4>일꾼</h4>
                  <p><strong>특수 능력</strong>: 아군 진영에 있을 때 턴 시작마다 행동 횟수를 1 추가로 부여합니다.</p>
                  <p>코스트 6 · 공격 0 · 체력 1 · 전진 1</p>
                </div>
              </div>
            </div>
          </div>
        </div>
    </div>

    <script>
        // 게임 상수 및 변수
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const endTurnBtn = document.getElementById('endTurnBtn');
        const messageBox = document.getElementById('messageBox');
        const playerHandDiv = document.getElementById('playerHand');

        // ===== Info Modals (Rules / Codex) =====
        const btnRules = document.getElementById('btnRules');
        const btnCodex = document.getElementById('btnCodex');
        const rulesModal = document.getElementById('rulesModal');
        const codexModal = document.getElementById('codexModal');

        function openModal(modalEl) {
          modalEl.classList.add('show');
          // focus trap: move focus to close button for accessibility
          const closeBtn = modalEl.querySelector('.modal-close');
          closeBtn && closeBtn.focus();
        }
        function closeModal(modalEl) {
          modalEl.classList.remove('show');
        }

        btnRules.addEventListener('click', () => openModal(rulesModal));
        btnCodex.addEventListener('click', () => openModal(codexModal));

        // close on overlay click or close button
        document.addEventListener('click', (e) => {
          const overlay = e.target.closest('.modal-overlay');
          if (!overlay) return;
          const isCloseBtn = e.target.matches('.modal-close');
          const clickedOutside = e.target === overlay; // backdrop click
          if (isCloseBtn || clickedOutside) {
            closeModal(overlay);
          }
        });
        // ESC to close
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            if (rulesModal.classList.contains('show')) closeModal(rulesModal);
            if (codexModal.classList.contains('show')) closeModal(codexModal);
          }
        });
        
        const GRID_WIDTH = 8;
        const GRID_HEIGHT = 12;
        const TILE_SIZE = 60;
        const SPECIAL_TILE_COLOR = '#8e44ad';
        const PADDING = 5;

        let turn = 1;
        let currentPlayer = 'player1';
        let player1Health = 10;
        let player2Health = 10;
        let player1Cost = 5;
        let player2Cost = 5;
        let playerMaxCost = 10;
        let opponentMaxCost = 10;
        let playerActionPoints = 5; 
        
        let player1Hand = [];
        let player1Deck = [];
        let player2Hand = [];
        let player2Deck = [];
        
        let gameBoard = []; // 필드 상태를 저장하는 8x12 배열

        let selectedCardInHand = null;
        let selectedCardOnBoard = null;

        // 카드 정의
        const cardTypes = [
            { id: 'soldier', name: '병사', cost: 1, baseHealth: 1, baseMove: 1, baseAttack: 1, baseRange: 1, type: 'soldier' },
            { id: 'archer', name: '아처', cost: 2, baseHealth: 1, baseMove: 1, baseAttack: 2, baseRange: 2, type: 'archer' },
            { id: 'shieldman', name: '방패병', cost: 2, baseHealth: 3, baseMove: 1, baseAttack: 2, baseRange: 1, type: 'shieldman' },
            { id: 'healer', name: '힐러', cost: 2, baseHealth: 1, baseMove: 1, baseAttack: 0, baseRange: 1, type: 'healer' },
            { id: 'wizard', name: '마법사', cost: 3, baseHealth: 1, baseMove: 1, baseAttack: 3, baseRange: 2, type: 'wizard' },
            { id: 'gunman', name: '총잡이', cost: 3, baseHealth: 1, baseMove: 1, baseAttack: 2, baseRange: 2, type: 'gunman' },
            { id: 'lancer', name: '말탄창병', cost: 5, baseHealth: 3, baseMove: 2, baseAttack: 5, baseRange: 1, type: 'lancer' },
            { id: 'bomber', name: '폭탄병', cost: 5, baseHealth: 1, baseMove: 1, baseAttack: 5, baseRange: 2, type: 'bomber' },
            { id: 'fighter', name: '투사', cost: 4, baseHealth: 3, baseMove: 1, baseAttack: 4, baseRange: 1, type: 'fighter' },
            { id: 'executioner', name: '사형수', cost: 8, baseHealth: 1, baseMove: 1, baseAttack: 1, baseRange: 1, type: 'executioner' },
            { id: 'suicider', name: '자살맨', cost: 10, baseHealth: 1, baseMove: 0, baseAttack: 0, baseRange: 0, type: 'suicider' },
            { id: 'vine', name: '넝쿨', cost: 4, baseHealth: 0, baseMove: 0, baseAttack: 0, baseRange: 0, type: 'magic' },
            { id: 'bat', name: '박쥐', cost: 1, baseHealth: 1, baseMove: 1, baseAttack: 1, baseRange: 1, type: 'creature' },
            { id: 'skeleton', name: '해골', cost: 1, baseHealth: 1, baseMove: 1, baseAttack: 1, baseRange: 1, type: 'creature' },
            { id: 'demon', name: '악마', cost: 5, baseHealth: 3, baseMove: 1, baseAttack: 5, baseRange: 1, type: 'creature' },
            // 추가된 카드
            { id: 'miner', name: '광부', cost: 2, baseHealth: 2, baseMove: 1, baseAttack: 1, baseRange: 1, type: 'worker' },
            { id: 'worker', name: '일꾼', cost: 6, baseHealth: 1, baseMove: 1, baseAttack: 0, baseRange: 1, type: 'worker' }
        ];

        // 게임 초기화
        function initGame() {
            gameBoard = Array(GRID_WIDTH).fill(null).map(() => Array(GRID_HEIGHT).fill(null));
            
            player1Deck = [];
            player2Deck = [];
            for (let i = 0; i < 20; i++) {
                player1Deck.push(cardTypes[Math.floor(Math.random() * cardTypes.length)]);
                player2Deck.push(cardTypes[Math.floor(Math.random() * cardTypes.length)]);
            }
            shuffleDeck(player1Deck);
            shuffleDeck(player2Deck);
            
            player1Hand = [];
            player2Hand = [];
            
            updateUI();
            drawBoard();
            renderHand();
            showMessage('게임이 시작됩니다! 플레이어 1의 턴입니다.');
        }

        function getPlayerState(player) {
            return {
                health: player === 'player1' ? player1Health : player2Health,
                cost: player === 'player1' ? player1Cost : player2Cost,
                deck: player === 'player1' ? player1Deck : player2Deck,
                hand: player === 'player1' ? player1Hand : player2Hand,
                team: player === 'player1' ? 'player' : 'opponent'
            };
        }

        function setPlayerState(player, key, value) {
            if (player === 'player1') {
                if (key === 'health') player1Health = value;
                if (key === 'cost') player1Cost = value;
            } else {
                if (key === 'health') player2Health = value;
                if (key === 'cost') player2Cost = value;
            }
        }

        // 덱 섞기 함수 (Fisher-Yates 알고리즘)
        function shuffleDeck(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // 카드 드로우
        function drawCard(player) {
            const { deck, hand } = getPlayerState(player);
            if (deck.length > 0) {
                hand.push(deck.pop());
            }
        }

        // 턴 시작 시 이벤트
        function startTurn() {
            if (checkGameOver()) {
                return;
            }

            // 모든 카드의 행동 상태 초기화 및 턴 수 증가
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const card = gameBoard[x][y];
                    if (card) {
                        card.hasActed = false;
                        card.turnsOnBoard = (card.turnsOnBoard || 0) + 1;

                        // 힐러 방어막 턴 감소
                        if (card.shieldTurns && card.shieldTurns > 0) {
                           card.shieldTurns--;
                           if (card.shieldTurns === 0) {
                               card.hasShield = false;
                               showMessage(`${card.name}의 방어막이 사라졌습니다.`);
                           }
                        }

                        // 투사 체력 회복
                        if (card.id === 'fighter') {
                            card.health = Math.min(card.maxHealth, card.health + 2);
                            showMessage(`${card.name}가 턴이 끝나고 체력을 2 회복했습니다!`);
                        }
                        
                        // 넝쿨 마법 턴 감소 및 제거
                        if (card.id === 'vine' && card.turnsOnBoard >= 2) {
                            gameBoard[x][y] = null;
                            showMessage('넝쿨 마법이 사라졌습니다.');
                        }
                    }
                }
            }
            
            applyBoardEffects();

            // 코스트 및 행동 횟수 초기화
            if (turn > 1) {
                const newCost = Math.min(getPlayerState(currentPlayer).cost + 3, playerMaxCost);
                setPlayerState(currentPlayer, 'cost', newCost);
            } else {
                setPlayerState(currentPlayer, 'cost', 5);
            }

            // 광부 능력: 아군 진영에 있을 때 코스트 +1 추가
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const card = gameBoard[x][y];
                    if (card && card.id === 'miner' && card.team === getPlayerState(currentPlayer).team) {
                        // 광부의 위치가 아군 진영인지 확인
                        const isPlayer1Territory = card.team === 'player' && y >= GRID_HEIGHT / 2;
                        const isPlayer2Territory = card.team === 'opponent' && y < GRID_HEIGHT / 2;
                        if (isPlayer1Territory || isPlayer2Territory) {
                            const newCost = Math.min(getPlayerState(currentPlayer).cost + 1, playerMaxCost);
                            setPlayerState(currentPlayer, 'cost', newCost);
                            showMessage(`광부가 턴 시작 시 코스트를 1 추가로 얻었습니다!`);
                        }
                    }
                }
            }
            
            playerActionPoints = 5; // 행동 횟수를 5로 변경

            // 일꾼 능력: 아군 진영에 있을 때 행동 횟수 +1 추가
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const card = gameBoard[x][y];
                    if (card && card.id === 'worker' && card.team === getPlayerState(currentPlayer).team) {
                        const isPlayer1Territory = card.team === 'player' && y >= GRID_HEIGHT / 2;
                        const isPlayer2Territory = card.team === 'opponent' && y < GRID_HEIGHT / 2;
                        if (isPlayer1Territory || isPlayer2Territory) {
                            playerActionPoints++;
                            showMessage(`일꾼이 턴 시작 시 행동 횟수를 1 추가로 얻었습니다!`);
                        }
                    }
                }
            }

            // 손에 있는 카드를 5장으로 맞춥니다
            const hand = getPlayerState(currentPlayer).hand;
            while (hand.length < 5) {
                drawCard(currentPlayer);
            }
            
            updateUI();
            drawBoard();
            renderHand();
            renderNextCards();
            showMessage(`플레이어 ${currentPlayer.slice(-1)}의 턴입니다!`);
        }

        // 보드 위 특수 효과 적용
        function applyBoardEffects() {
            let totalPlayer1Damage = 0;
            let totalPlayer2Damage = 0;

            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const card = gameBoard[x][y];
                    if (card) {
                        if (card.team === 'player' && card.y === 0) {
                            const damage = Math.floor(card.cost / 2);
                            player2Health -= damage;
                            totalPlayer1Damage += damage;
                        }
                        if (card.team === 'opponent' && card.y === GRID_HEIGHT - 1) {
                            const damage = Math.floor(card.cost / 2);
                            player1Health -= damage;
                            totalPlayer2Damage += damage;
                        }
                    }
                }
            }

            if (totalPlayer1Damage > 0) {
                showMessage(`플레이어 1의 카드가 플레이어 2에게 ${totalPlayer1Damage}의 데미지를 입혔습니다!`);
            }
            if (totalPlayer2Damage > 0) {
                showMessage(`플레이어 2의 카드가 플레이어 1에게 ${totalPlayer2Damage}의 데미지를 입혔습니다!`);
            }
        }

        // 턴 종료 버튼 이벤트
        endTurnBtn.addEventListener('click', () => {
            turn++;
            if (currentPlayer === 'player1') {
                currentPlayer = 'player2';
            } else {
                currentPlayer = 'player1';
            }
            startTurn();
        });

        function checkGameOver() {
            if (player1Health <= 0) {
                showMessage('플레이어 2 승리!');
                endTurnBtn.disabled = true;
                return true;
            }
            if (player2Health <= 0) {
                showMessage('플레이어 1 승리!');
                endTurnBtn.disabled = true;
                return true;
            }
            return false;
        }

        // UI 업데이트
        function updateUI() {
            document.getElementById('player1Health').textContent = player1Health;
            document.getElementById('player2Health').textContent = player2Health;
            document.getElementById('player1Cost').textContent = player1Cost;
            document.getElementById('player2Cost').textContent = player2Cost;
            document.getElementById('turnCounter').textContent = Math.ceil(turn / 2);
            document.getElementById('actionPoints').textContent = playerActionPoints;
            document.getElementById('currentPlayerLabel').textContent = currentPlayer === 'player1' ? '플레이어 1' : '플레이어 2';
        }

        // 메시지 박스
        function showMessage(msg) {
            messageBox.textContent = msg;
        }

        // 핸드 카드 렌더링
        function renderHand() {
            playerHandDiv.innerHTML = '';
            const { hand } = getPlayerState(currentPlayer);
            hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.dataset.index = index;
                if (selectedCardInHand && selectedCardInHand.index === index) {
                    cardDiv.classList.add('selected');
                }
                // 행동 제한 카드 여부 확인
                let isDisabled = false;
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const disabledCard = gameBoard[x][card.y];
                    if (disabledCard && disabledCard.id === 'vine') {
                        isDisabled = true;
                        break;
                    }
                }
                
                if (isDisabled) {
                    cardDiv.classList.add('disabled-action');
                }

                cardDiv.innerHTML = `
                    <span class="cost-circle">${card.cost}</span>
                    <div class="card-name">${card.name}</div>
                    <div class="card-stats">
                        <div class="card-stat"><span>체력:</span> ${card.baseHealth}</div>
                        <div class="card-stat"><span>이동:</span> ${card.baseMove}</div>
                        <div class="card-stat"><span>공격력:</span> ${card.baseAttack}</div>
                    </div>
                `;
                cardDiv.addEventListener('click', () => {
                    if (card.id === 'demon') {
                        // 악마 카드 선택 시, 필드에 있는 아군 병사를 먼저 선택하도록 유도
                        selectedCardInHand = { card: card, index: index };
                        selectedCardOnBoard = null;
                        showMessage('악마를 소환하려면 먼저 잡아먹을 아군 병사를 선택하세요.');
                        drawBoard();
                        return;
                    }
                    if (selectedCardInHand && selectedCardInHand.index === index) {
                        selectedCardInHand = null;
                    } else {
                        selectedCardInHand = { card: card, index: index };
                        selectedCardOnBoard = null;
                        showMessage(`카드를 선택했습니다: ${card.name}. 필드에 놓을 위치를 선택하세요.`);
                    }
                    renderHand();
                    drawBoard();
                });
                playerHandDiv.appendChild(cardDiv);
            });
        }
        
        // 다음 카드 렌더링
        function renderNextCards() {
            const nextCardsDiv = document.getElementById('nextCards');
            nextCardsDiv.innerHTML = '';
            const { deck } = getPlayerState(currentPlayer);
            for (let i = 0; i < Math.min(2, deck.length); i++) {
                const card = deck[deck.length - 1 - i];
                const cardDiv = document.createElement('div');
                cardDiv.className = 'next-card';
                cardDiv.textContent = `${card.name} (코스트: ${card.cost})`;
                nextCardsDiv.appendChild(cardDiv);
            }
        }
        
        // 유효한 이동 위치를 반환하는 함수
        function getValidMoves(card) {
            const moves = [];
            const { x, y, move, id } = card;

            const moveRange = (id === 'lancer') ? 2 : move;

            for (let dx = -moveRange; dx <= moveRange; dx++) {
                for (let dy = -moveRange; dy <= moveRange; dy++) {
                    // Check for cardinal moves for lancer
                    if (id === 'lancer' && dx !== 0 && dy !== 0) continue;
                    
                    if (dx === 0 && dy === 0) continue;
                    
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT && gameBoard[newX][newY] === null) {
                        moves.push({ x: newX, y: newY });
                    }
                }
            }
            return moves;
        }

        // 힐러의 유효한 힐 대상을 반환하는 함수
        function getHealableTargets(card) {
            const targets = [];
            const { x, y } = card;

            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {
                        const targetCard = gameBoard[newX][newY];
                        if (targetCard && targetCard.team === card.team && !targetCard.hasShield) {
                            targets.push({ x: newX, y: newY });
                        }
                    }
                }
            }
            return targets;
        }

        // 유효한 공격 대상을 반환하는 함수
        function getValidAttacks(card) {
            const attacks = [];
            const { x, y, range, team } = card;

            const minX = Math.max(0, x - range);
            const maxX = Math.min(GRID_WIDTH - 1, x + range);
            const minY = Math.max(0, y - range);
            const maxY = Math.min(GRID_HEIGHT - 1, y + range);

            for (let col = minX; col <= maxX; col++) {
                for (let row = minY; row <= maxY; row++) {
                    const targetCard = gameBoard[col][row];
                    if (targetCard && targetCard.team !== team) {
                        attacks.push({ x: col, y: row });
                    }
                }
            }
            return attacks;
        }

        // 필드 그리기
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;
                    ctx.beginPath();
                    ctx.rect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;

                    if (y === 0 || y === GRID_HEIGHT - 1) {
                        ctx.fillStyle = '#87CEEB';
                        ctx.globalAlpha = 0.5;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    } else if (y >= GRID_HEIGHT / 2) {
                        ctx.fillStyle = SPECIAL_TILE_COLOR;
                        ctx.globalAlpha = 0.2;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    } else {
                        ctx.fillStyle = '#222';
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }

            ctx.beginPath();
            ctx.moveTo(0, GRID_HEIGHT / 2 * TILE_SIZE);
            ctx.lineTo(canvas.width, GRID_HEIGHT / 2 * TILE_SIZE);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.stroke();

            if (selectedCardInHand) {
                const card = selectedCardInHand.card;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                
                // 자살맨은 상대 진영에만 하이라이트
                if (card.id === 'suicider') {
                    const highlightYStart = currentPlayer === 'player1' ? 0 : GRID_HEIGHT / 2;
                    const highlightYEnd = currentPlayer === 'player1' ? GRID_HEIGHT / 2 : GRID_HEIGHT;
                    for (let y = highlightYStart; y < highlightYEnd; y++) {
                        for (let x = 0; x < GRID_WIDTH; x++) {
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                } else if (card.type === 'magic') {
                    // 마법 카드는 모든 진영에 하이라이트
                    for (let y = 0; y < GRID_HEIGHT; y++) {
                        for (let x = 0; x < GRID_WIDTH; x++) {
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                } else {
                    let highlightY = currentPlayer === 'player1' ? (GRID_HEIGHT - 1) * TILE_SIZE : 0;
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        ctx.fillRect(x * TILE_SIZE, highlightY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            if (selectedCardOnBoard) {
                const { x, y } = selectedCardOnBoard.coords;
                ctx.fillStyle = '#FFD700';
                ctx.globalAlpha = 0.5;
                ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.globalAlpha = 1.0;

                const card = gameBoard[x][y];
                if (card.team === getPlayerState(currentPlayer).team && !card.hasActed && playerActionPoints > 0) {
                    const validMoves = getValidMoves(card);
                    validMoves.forEach(move => {
                        ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                        ctx.fillRect(move.x * TILE_SIZE, move.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    });

                    const validAttacks = getValidAttacks(card);
                    validAttacks.forEach(attack => {
                        ctx.fillStyle = 'rgba(231, 76, 60, 0.5)';
                        ctx.fillRect(attack.x * TILE_SIZE, attack.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    });

                    if (card.id === 'healer') {
                        const healableTargets = getHealableTargets(card);
                        healableTargets.forEach(target => {
                            ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
                            ctx.fillRect(target.x * TILE_SIZE, target.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        });
                    }
                }
            }
            
            for (let x = 0; x < GRID_WIDTH; x++) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    const card = gameBoard[x][y];
                    if (card) {
                        const tileX = x * TILE_SIZE;
                        const tileY = y * TILE_SIZE;
                        
                        // 넝쿨 마법 효과 표시
                        if (card.id === 'vine') {
                            ctx.fillStyle = '#27ae60';
                            ctx.globalAlpha = 0.7;
                            ctx.fillRect(tileX, 0, TILE_SIZE, canvas.height);
                            ctx.globalAlpha = 1.0;
                        }

                        ctx.fillStyle = card.team === 'player' ? '#2ecc71' : '#e74c3c';
                        ctx.fillRect(tileX + PADDING, tileY + PADDING, TILE_SIZE - PADDING * 2, TILE_SIZE - PADDING * 2);
                        
                        // 방어막이 있다면 흰색 테두리 추가
                        if (card.hasShield) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 3;
                            ctx.strokeRect(tileX + PADDING, tileY + PADDING, TILE_SIZE - PADDING * 2, TILE_SIZE - PADDING * 2);
                        }

                        ctx.fillStyle = '#222';
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(card.name, tileX + TILE_SIZE / 2, tileY + 10);
                        
                        ctx.font = '12px Arial';
                        ctx.fillText(`체력: ${card.health}`, tileX + TILE_SIZE / 2, tileY + 30);
                        ctx.fillText(`공격: ${card.attack}`, tileX + TILE_SIZE / 2, tileY + 45);
                    }
                }
            }
        }

        // 공격 처리 로직
        function handleAttack(attacker, targetCoords) {
            const { x, y } = targetCoords;
            const targetCard = gameBoard[x][y];
            
            if (!targetCard) {
                showMessage('잘못된 공격 대상입니다.');
                return;
            }

            // 폭탄병 특수능력 (십자가 범위 공격)
            if (attacker.id === 'bomber') {
                const affectedTiles = [
                    { x, y },
                    { x: x - 1, y }, { x: x + 1, y },
                    { x, y: y - 1 }, { x, y: y + 1 }
                ];
                affectedTiles.forEach(tile => {
                    if (tile.x >= 0 && tile.x < GRID_WIDTH && tile.y >= 0 && tile.y < GRID_HEIGHT) {
                        const splashTarget = gameBoard[tile.x][tile.y];
                        if (splashTarget && splashTarget.team !== attacker.team) {
                            const damage = attacker.attack + 2;
                            if (splashTarget.hasShield) {
                                splashTarget.hasShield = false;
                                showMessage(`${splashTarget.name}의 방어막이 공격을 막았습니다!`);
                            } else {
                                splashTarget.health -= damage;
                            }
                            if (splashTarget.health <= 0) {
                                gameBoard[tile.x][tile.y] = null;
                            }
                        }
                    }
                });
                showMessage('폭탄병이 십자가 형태로 공격했습니다!');
            }
            // 마법사 특수능력 (뒤쪽 칸까지 공격)
            else if (attacker.id === 'wizard') {
                const behindY = targetCard.team === 'player' ? y - 1 : y + 1;
                const affectedTiles = [{ x, y }];
                if (behindY >= 0 && behindY < GRID_HEIGHT) {
                     affectedTiles.push({ x, y: behindY });
                }

                affectedTiles.forEach(tile => {
                    const splashTarget = gameBoard[tile.x][tile.y];
                    if (splashTarget) {
                        const damage = 1; // 특수능력 피해량 1
                        if (splashTarget.hasShield) {
                           splashTarget.hasShield = false;
                           showMessage(`${splashTarget.name}의 방어막이 공격을 막았습니다!`);
                        } else {
                           splashTarget.health -= damage;
                        }
                        if (splashTarget.health <= 0) {
                            gameBoard[tile.x][tile.y] = null;
                        }
                    }
                });
                showMessage('마법사가 대상을 관통하는 공격을 했습니다!');

                const finalDamage = attacker.attack;
                if (targetCard.hasShield) {
                    targetCard.hasShield = false;
                    showMessage(`${targetCard.name}의 방어막이 공격을 막았습니다!`);
                } else {
                    targetCard.health -= finalDamage;
                }
                if (targetCard.health <= 0) {
                    gameBoard[x][y] = null;
                }
            }
            // 총잡이 특수능력 (상대 진영에서 2회 공격)
            else if (attacker.id === 'gunman' && attacker.isOpponentTerritory) {
                const damage = 4; // 상대 진영에서 공격력 4 고정
                if (targetCard.hasShield) {
                    targetCard.hasShield = false;
                    showMessage(`${targetCard.name}의 방어막이 공격을 막았습니다!`);
                } else {
                    targetCard.health -= damage;
                }
                if (targetCard.health <= 0) {
                    gameBoard[x][y] = null;
                } else {
                    if (targetCard.hasShield) {
                        targetCard.hasShield = false;
                        showMessage(`${targetCard.name}의 방어막이 2번째 공격을 막았습니다!`);
                    } else {
                        targetCard.health -= damage;
                    }
                    if (targetCard.health <= 0) {
                        gameBoard[x][y] = null;
                    }
                }
                showMessage('총잡이가 2번 공격했습니다!');
            }
            // 일반 공격
            else {
                if (targetCard.hasShield) {
                   targetCard.hasShield = false;
                   showMessage(`${targetCard.name}의 방어막이 공격을 막았습니다!`);
                } else {
                   targetCard.health -= attacker.attack;
                }

                if (targetCard.health <= 0) {
                    gameBoard[x][y] = null;
                    showMessage('상대 카드를 파괴했습니다!');
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            if (checkGameOver()) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const x = Math.floor(mouseX / TILE_SIZE);
            const y = Math.floor(mouseY / TILE_SIZE);
            
            const currentPlayerTeam = getPlayerState(currentPlayer).team;
            const opponentPlayerTeam = currentPlayerTeam === 'player' ? 'opponent' : 'player';

            if (selectedCardInHand) {
                const card = selectedCardInHand.card;
                const { cost } = getPlayerState(currentPlayer);

                if (card.id === 'suicider') {
                    const isPlacementValid = (currentPlayer === 'player1' && y < GRID_HEIGHT / 2) || (currentPlayer === 'player2' && y >= GRID_HEIGHT / 2);
                    if (isPlacementValid && gameBoard[x][y] === null) {
                        if (cost >= card.cost) {
                            setPlayerState(currentPlayer, 'cost', cost - card.cost);
                            showMessage(`자살맨이 ${x}, ${y}에 소환되었습니다!`);
                            
                            const damage = 2;
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const targetX = x + dx;
                                    const targetY = y + dy;

                                    if (targetX >= 0 && targetX < GRID_WIDTH && targetY >= 0 && targetY < GRID_HEIGHT) {
                                        const targetCard = gameBoard[targetX][targetY];
                                        if (targetCard && targetCard.team === opponentPlayerTeam) {
                                            if (targetCard.hasShield) {
                                                targetCard.hasShield = false;
                                                showMessage(`${targetCard.name}의 방어막이 공격을 막았습니다!`);
                                            } else {
                                                targetCard.health -= damage;
                                                if (targetCard.health <= 0) {
                                                    gameBoard[targetX][targetY] = null;
                                                    showMessage(`${targetCard.name}가 파괴되었습니다!`);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            getPlayerState(currentPlayer).hand.splice(selectedCardInHand.index, 1);
                            selectedCardInHand = null;
                        } else {
                            showMessage('코스트가 부족합니다.');
                        }
                    } else {
                        showMessage('자살맨은 상대 진영에만 놓을 수 있습니다.');
                    }
                } else if (card.type === 'magic') {
                    if (gameBoard[x][y] === null) {
                        if (cost >= card.cost) {
                            setPlayerState(currentPlayer, 'cost', cost - card.cost);
                            gameBoard[x][y] = { 
                                ...card, 
                                x, 
                                y, 
                                hasActed: false, 
                                turnsOnBoard: 0,
                                team: currentPlayerTeam,
                                health: card.baseHealth,
                                maxHealth: card.baseHealth,
                                attack: card.baseAttack,
                                move: card.baseMove,
                                range: card.baseRange,
                                isOpponentTerritory: false,
                                hasShield: false,
                                shieldTurns: 0
                            };
                            getPlayerState(currentPlayer).hand.splice(selectedCardInHand.index, 1);
                            selectedCardInHand = null;
                            showMessage(`${card.name} 마법을 ${x}, ${y}에 시전했습니다.`);

                            // 넝쿨 마법 효과 적용: 해당 세로 라인 모든 카드 행동 제한
                            if (card.id === 'vine') {
                                for (let i = 0; i < GRID_HEIGHT; i++) {
                                    const targetCard = gameBoard[x][i];
                                    if (targetCard) {
                                        targetCard.hasActed = true;
                                        showMessage(`${targetCard.name}이(가) 넝쿨에 묶여 행동할 수 없습니다.`);
                                    }
                                }
                            }

                        } else {
                            showMessage('코스트가 부족합니다.');
                        }
                    } else {
                        showMessage('마법은 빈 칸에만 소환할 수 있습니다.');
                    }
                } else if (card.id === 'demon') {
                    // 악마는 아군 병사를 잡아먹고 그 자리에 소환
                    const isTargetSoldier = gameBoard[x][y] && gameBoard[x][y].team === currentPlayerTeam && gameBoard[x][y].id === 'soldier';
                    if (isTargetSoldier) {
                         if (cost >= card.cost) {
                            setPlayerState(currentPlayer, 'cost', cost - card.cost);
                            gameBoard[x][y] = { 
                                ...card, 
                                x, 
                                y, 
                                hasActed: false, 
                                turnsOnBoard: 0,
                                team: currentPlayerTeam,
                                health: card.baseHealth,
                                maxHealth: card.baseHealth,
                                attack: card.baseAttack,
                                move: card.baseMove,
                                range: card.baseRange,
                                isOpponentTerritory: false,
                                hasShield: false,
                                shieldTurns: 0
                            };
                            gameBoard[x][y].hasActed = false; // 소환된 즉시 공격 가능
                            getPlayerState(currentPlayer).hand.splice(selectedCardInHand.index, 1);
                            selectedCardInHand = null;
                            showMessage(`악마가 병사를 잡아먹고 ${x}, ${y}에 소환되었습니다. 바로 공격할 수 있습니다!`);
                        } else {
                            showMessage('코스트가 부족합니다.');
                        }
                    } else {
                        showMessage('악마는 아군 병사를 잡아먹고 소환될 수 있습니다.');
                    }
                } else { // 일반 카드 배치 로직
                    const isPlacementValid = (currentPlayer === 'player1' && y === GRID_HEIGHT - 1) || (currentPlayer === 'player2' && y === 0);
                    if (isPlacementValid && gameBoard[x][y] === null) {
                        if (cost >= card.cost) {
                            setPlayerState(currentPlayer, 'cost', cost - card.cost);
                            gameBoard[x][y] = { 
                                ...card, 
                                x, 
                                y, 
                                hasActed: false, 
                                turnsOnBoard: 0,
                                team: currentPlayerTeam,
                                health: card.baseHealth,
                                maxHealth: card.baseHealth,
                                attack: card.baseAttack,
                                move: card.baseMove,
                                range: card.baseRange,
                                isOpponentTerritory: false,
                                hasShield: false,
                                shieldTurns: 0
                            };
                            getPlayerState(currentPlayer).hand.splice(selectedCardInHand.index, 1);
                            selectedCardInHand = null;
                            showMessage(`카드를 필드에 배치했습니다.`);
                        } else {
                            showMessage('코스트가 부족합니다.');
                        }
                    } else {
                        showMessage('카드는 시작 진영에만 놓을 수 있습니다.');
                    }
                }
            } else if (selectedCardOnBoard) {
                const card = gameBoard[selectedCardOnBoard.coords.x][selectedCardOnBoard.coords.y];
                const targetTile = { x, y };

                if (card.hasActed || playerActionPoints < 1) {
                    showMessage('이 카드는 이미 행동했거나 행동 횟수가 부족합니다.');
                    selectedCardOnBoard = null;
                    drawBoard();
                    return;
                }

                // 6코스트 이상 카드 행동불가 규칙 (사형수 제외)
                if (card.cost >= 6 && card.id !== 'executioner' && card.turnsOnBoard < 5) {
                    showMessage('이 카드는 5턴 동안 행동할 수 없습니다.');
                    selectedCardOnBoard = null;
                    drawBoard();
                    return;
                }
                
                // 넝쿨 마법에 묶인 카드 행동 제한
                const vineAtColumn = gameBoard[card.x].find(tile => tile && tile.id === 'vine');
                if (vineAtColumn) {
                    showMessage('이 카드는 넝쿨에 묶여 행동할 수 없습니다!');
                    selectedCardOnBoard = null;
                    drawBoard();
                    return;
                }

                const validMoves = getValidMoves(card);
                const isValidMove = validMoves.some(m => m.x === targetTile.x && m.y === targetTile.y);
                
                const validAttacks = getValidAttacks(card);
                const isValidAttack = validAttacks.some(a => a.x === targetTile.x && a.y === targetTile.y);
                
                const healableTargets = (card.id === 'healer') ? getHealableTargets(card) : [];
                const isValidHeal = healableTargets.some(h => h.x === targetTile.x && h.y === targetTile.y);

                if (isValidMove) {
                    gameBoard[x][y] = { ...card, x, y };
                    gameBoard[selectedCardOnBoard.coords.x][selectedCardOnBoard.coords.y] = null;
                    gameBoard[x][y].hasActed = true;
                    playerActionPoints--;
                    showMessage(`카드가 이동했습니다. 남은 행동 횟수: ${playerActionPoints}`);

                    const isOpponentTerritory = (card.team === 'player' && y < GRID_HEIGHT / 2) || (card.team === 'opponent' && y >= GRID_HEIGHT / 2);
                    if (isOpponentTerritory && !card.isOpponentTerritory) {
                        applySpecialAbility(gameBoard[x][y]);
                        gameBoard[x][y].isOpponentTerritory = true;
                    }
                    if (card.id === 'executioner') {
                        gameBoard[x][y].health = Math.min(15, gameBoard[x][y].health + 1);
                        gameBoard[x][y].maxHealth = Math.min(15, gameBoard[x][y].maxHealth + 1);
                        showMessage('사형수가 이동하여 최대 체력이 증가했습니다!');
                    }
                } else if (isValidAttack) {
                    handleAttack(card, targetTile);
                    card.hasActed = true;
                    playerActionPoints--;
                } else if (isValidHeal && card.id === 'healer') {
                    const targetCard = gameBoard[x][y];
                    targetCard.hasShield = true;
                    targetCard.shieldTurns = 2; // 2턴 지속
                    card.hasActed = true;
                    playerActionPoints--;
                    showMessage(`힐러가 ${targetCard.name}에게 방어막을 생성했습니다!`);
                } else {
                    showMessage('유효한 행동이 아닙니다.');
                }
                
                selectedCardOnBoard = null;
            } else {
                if (gameBoard[x][y] && gameBoard[x][y].team === currentPlayerTeam) {
                    selectedCardOnBoard = { card: gameBoard[x][y], coords: { x, y } };
                    showMessage(`카드를 선택했습니다. 이동 또는 공격할 대상을 클릭하세요.`);
                } else {
                    showMessage('카드를 선택하지 않았습니다. 핸드에서 카드를 선택하거나 필드 카드를 클릭하세요.');
                }
            }
            
            updateUI();
            drawBoard();
            renderHand();
            checkGameOver();
        });

        function applySpecialAbility(card) {
            const isPlayer1 = card.team === 'player';
            const isCrossing = (isPlayer1 && card.y < GRID_HEIGHT / 2) || (!isPlayer1 && card.y >= GRID_HEIGHT / 2);

            if (isCrossing) {
                switch (card.id) {
                    case 'archer':
                        card.attack = Math.max(0, card.baseAttack - 1);
                        showMessage(`${isPlayer1 ? '플레이어 1' : '플레이어 2'}의 ${card.name}이(가) 상대 진영으로 넘어가서 공격력이 약해졌습니다.`);
                        break;
                    case 'shieldman':
                        card.health = card.baseHealth + 2;
                        card.attack = Math.max(0, card.baseAttack - 1);
                        showMessage(`${isPlayer1 ? '플레이어 1' : '플레이어 2'}의 ${card.name}이(가) 상대 진영으로 넘어가서 방어력이 강해졌습니다.`);
                        break;
                    case 'fighter':
                        card.health += 3;
                        card.maxHealth += 3;
                        showMessage(`${isPlayer1 ? '플레이어 1' : '플레이어 2'}의 ${card.name}이(가) 상대 진영으로 넘어가 체력이 증가했습니다!`);
                        break;
                }
            }
        }

        // 초기 시작
        initGame();
        startTurn();
    </script>
</body>
</html>
